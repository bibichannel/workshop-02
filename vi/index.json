[{"uri":"https://bibichannel.github.io/workshop-02/vi/1-introduce/","title":"Giới thiệu","tags":[],"description":"","content":"\nNhìn vào architecture các bạn cũng đã thấy, đây là một project khá lớn với nhiều dịch vụ của AWS serivices đi kèm theo:\nDeploy application lên 2 AZ để tăng tính high availability và phân tải đến các ứng dụng qua Application Load Balancer (ALB). Tạo pipeline từ Codepipeline cho streamlit application và deploy lên dịch vụ serverless Elastic Container Service. Sử dụng Codebuild để build images và lưu giữ image trên Elastic Container Registry (ECR). Nhận thông báo trạng thái pipeline về email với EventBridge và Amazon SNS. Sử dụng Route53 để custom domain cho riêng mình. Sẽ thế nào nếu bạn phải tương tác bằng tay để setup các dịch vụ trên? Hoặc là khi bạn chuyển giao project này cho người trong team, liệu người đó có setup đúng và chính xác những gì bạn đã document trước đó. Hay là khi sếp bạn thấy project bạn làm rất tốt nên muốn áp dụng kiến trúc này cho các project tiếp theo, thì việc setup một lượng lớn các dịch vụ như vậy khiến ta không thể nào không mắc sai lầm được. Chính vì lẽ đó việc cung cấp cơ sở hạ tầng dưới dạng mã ra đời. Nó giúp chúng ta có thể nhanh chóng trong việc triển khai, hạn chế lỗi con người,\u0026hellip;\nĐây cũng chính là mục đích của mình khi làm bài viết này. Thông qua workshop này có thể giúp bạn có thể tự tin setup một dự án với terraform trên nền tảng AWS Cloud.\nỞ đây mình sẽ có 2 repository trên github với các mục đích như sau:\nRepository đầu tiên mình sẽ lưu terraform code để provisioning tới aws thông qua git action. Điều này sẽ giúp mình có thể downgrade version mỗi khi cấu hình được thay đổi bị lỗi thông qua việc quản lí version trên github. Và nó cũng giúp chúng ta cũng có thể teamwork được với nhau. Repository thứ hai mình sẽ lưu source code của streamlit app, mỗi khi push code lên repo thì nó sẽ được push event thông qua webhook để Codepipeline được trigger, build và deploy lên ECS Fargate. "},{"uri":"https://bibichannel.github.io/workshop-02/vi/5-provisioningtesting/5.1-local/","title":"Local","tags":[],"description":"","content":"Chuẩn bị Với việc chạy trên local thì chúng ta cần phải có thêm 2 tệp nữa là terraform.tfvars và vars.tfbackend. Hai tệp này sẽ gán value các biến môi trường đã được định nghĩa trong tệp variables.tf ở thư mục root và cấu hình backend lưu trữ trên S3 bucket.\nVới terraform.tfvars bạn sẽ có nội dung như sau: aws_region = \u0026#34;us-east-1\u0026#34; stage_name = \u0026#34;staging\u0026#34; project_name = \u0026#34;workshop-02\u0026#34; create_by = \u0026lt;Your name\u0026gt; github_repo = \u0026lt;GitHubOrg/GitHubRepo\u0026gt; github_branch = \u0026#34;main\u0026#34; codestar_connection_arn = \u0026lt;CodeStar Conneciton ARN\u0026gt; account_id = \u0026lt;Account ID AWS\u0026gt; Biến github_repo là tên của github repo chứa source code streamlit app tạo ở bước 3.2. Biến này được sử dụng cấu hình cho stage source của Codepipeline services. Biến github_branch là nhánh của github repo chứa source code streamlit app bạn muốn theo dõi trạng thái. Biến này được sử dụng cấu hình cho stage source của Codepipeline services. Biến codestar_connection_arn chứa ARN của Connection tạo ở bước 2.4. Biến này được dùng cho việc cấu hình stage source của Codepipeline services. Biến account_id này chứa id của aws account của bạn, biến này được sử dụng cho việc tạo role của dịch vụ Amazon Simple Notification Service (SNS). Ngoài các biến mình để cập các biến còn lại sẽ là các common variables cho các modules dùng hoặc để đánh tags các resources. Với vars.tfbackend bạn sẽ có nội dung như sau: bucket = \u0026lt;Bucket\u0026#39;s name\u0026gt; key = \u0026#34;terraform-staging/terraform.tfstate\u0026#34; region = \u0026#34;us-east-1\u0026#34; Với việc cấu hình backend cho terraform lưu trữ state file trên S3 sẽ cần khai báo những biến như trên. Việc sử dụng backend sẽ giúp ta khi code terraform có thể teamwork với nhau, bảo mật state file,\u0026hellip; Biến bucket chứa thông tin bucket bạn dùng để lưu backend mà ta đã tạo ở bước 2.3. Biến key cấu hình prefix cho đường dẫn tới file terraform trong bucket. Biến region xác định xem bucket của bạn nằm ở region nào. Bạn có thể đọc thêm thông tin về cách tạo backend cho terraform tại backend s3. Bạn truy cập file main.tf ở root directory trong source code, tìm tới locals block: locals { tags = { Project = var.project_name CreateBy = var.create_by Environment = var.stage_name } container_name = \u0026#34;streamlit-app\u0026#34; container_port = 8501 container_cpu = 512 container_memory = 1024 notification_email = \u0026#34;trung.lykhanh150901@gmail.com\u0026#34; } Ngoài tags list chứa các key:value với value được pass từ terraform.tfvars file thì ta sẽ quan tâm tới các biến sau. container_name là biến đặt tên cho container trong cấu hình ECS services. container_port port của containter được expose. container_cpu giới hạn cpu cho fargate task definitions. notification_email là email được đăng ký với dịch vụ SNS, nhận thông báo change state của Codepipeline. Hãy thay đổi thông tin các biến cho phù hợp với bạn.\nTiến hành chạy Sau khi bạn đã có 2 tệp trên thì bây giờ bạn chạy lần lượt câu lệnh sau:\nterraform init -backend-config=\u0026#39;vars.tfbackend\u0026#39; Câu lệnh này sẽ tiến hành cài đặt các plugin cho provider bạn đã khai báo trong providers.tf file, khởi tạo một môi trường Terraform trong thư mục hiện tại. Cấu hình backend sử dụng các thông số từ vars.tfbackend file, thông qua cờ -backend-config. Load các module ta đã viết.\nDưới đây là hình ảnh sau khi chạy câu lệnh trên.\nterraform validate Được sử dụng để kiểm tra xem tất cả các tệp cấu hình Terraform của bạn có đúng cú pháp và hợp lệ hay không, mà không cần thực hiện bất kỳ thay đổi nào đến hạ tầng thực tế. Điều này giúp bạn phát hiện lỗi cú pháp hoặc lỗi logic trước khi áp dụng bất kỳ thay đổi nào.\nDưới đây là hình ảnh sau khi chạy câu lệnh trên.\nterraform plan Được sử dụng để tạo ra một kế hoạch thực hiện các thay đổi trên hạ tầng dựa trên cấu hình Terraform và state hiện tại mà không thực hiện các thay đổi thực tế. Điều này cho phép bạn xem trước những gì sẽ xảy ra nếu bạn áp dụng các thay đổi này.\nKhi bạn chạy terraform plan, Terraform sẽ đọc cấu hình của bạn và state hiện tại, sau đó so sánh chúng để xác định những thay đổi cần thực hiện để đạt được trạng thái mới. Kết quả của lệnh này sẽ hiển thị danh sách các hành động mà Terraform sẽ thực hiện, bao gồm việc tạo, cập nhật hoặc xóa các tài nguyên.\nNó cũng cung cấp thông tin về tài nguyên nào sẽ được thay đổi, tài nguyên nào sẽ được thêm vào, và tài nguyên nào sẽ bị xóa (nếu có). Ngoài ra, nó cung cấp một ước lượng về chi phí và thời gian cần thiết để thực hiện các thay đổi.\nDưới đây là hình ảnh sau khi chạy câu lệnh trên.\nterraform apply -auto-approve Lệnh terraform apply -auto-approve sẽ thực hiện áp dụng các thay đổi đã được kế hoạch bởi Terraform mà không cần xác nhận thêm từ người dùng. Điều này có nghĩa là Terraform sẽ tự động thực hiện các thay đổi mà không cần phải yêu cầu sự xác nhận nào từ bạn.\nDưới đây là hình ảnh sau khi chạy câu lệnh trên.\nSẽ có những resources mất thời gian để tạo nhưng sau khi tạo xong nó sẽ thông thông báo apply compelete. Kiểm tra trên AWS Consonle Truy cập lần lượt các console sau để kiểm tra thông tin resources ta đã tạo:\nVPC console link Codepipeline console link ECR console link ECS console link SNS topic console link EvenBridge rule console link Enpoint console link S3 bucket link ALB console link Thông tin về state change của codepipeline được gửi về email đã đăng ký. Bạn nhớ check mail sớm để Subscription email của bạn cho SNS services nhé.\nTruy cập thông tin sau dây để xem thử website đã được build.\nContainer 1 Container 2 Như ta thấy web đã hoạt động tốt, loadbalancer định tuyến traffic vào 2 container.\nBạn có để ý thấy ở đây mình dùng DNS của loadbalancer. Nhưng trong architect ban đầu có cấu hình thêm route53 mà!!! Vì làm một mạch theo workshop luôn sẽ không đánh thức sự tò mò của bạn nên module cuối cùng mình sẽ để các bạn tự viết nó và triển khai một tên miền do chính các bạn đăng ký. Hãy thử thách bản thân và tạo nên một hệ thống hoàn chỉnh cho bức tranh này nhé. Mình tin bạn có thể làm được nếu đã đọc tới đây.\nThực hiện push code mới lên repository streamlit app Bạn hãy thay đổi bất kì đoạn mã hay văn bản nào trong thư mục chứa source code của streamlit app và push nó lên github. Quay lại Codepipeline console để xem pipeline có được hoạt động đúng không. Check email trả về khi codepipeline thay đổi trạng thái và check ECS fargate services xem task đã được tạo mới hay chưa nhé.\nDestroy cơ sở hạ tầng Chạy câu lệnh sau để huỷ cơ sở hạ tầng bạn đã provisioned.\nterraform destroy -auto-approve "},{"uri":"https://bibichannel.github.io/workshop-02/vi/4-knowledgeterraform/4.1-overview/","title":"Overview","tags":[],"description":"","content":"1. Tổng quan về terraform Terraform là một open-source của HashiCorp, chuyên dùng để provisioning infrastructure, ta chỉ việc viết code, rồi gõ một vài câu CLI đơn giản, nó sẽ tạo ra Infrastructure cho ta.\nNgôn ngữ Terraform sử dụng gọi là HashiCorp Configuration Language (HCL)\nFlow của terraform sẽ như sau, ta viết code, xong ta gõ câu lệnh CLI, và đợi nó cung cấp infrastructure, sau khi nó tạo xong thì nó sẽ tạo ra một file state để lưu lại kiến trúc hạ tầng hiện tại của ta. State là một bản ghi của hạ tầng hiện tại mà Terraform đã quản lý. Nó được sử dụng để theo dõi các tài nguyên đã được tạo, sửa đổi hoặc xóa. State cũng giúp Terraform xác định những thay đổi cần thực hiện để đạt được trạng thái mong muốn của hạ tầng.\nState file: Mặc định, Terraform lưu trữ state trong một tệp có tên terraform.tfstate trong thư mục làm việc hiện tại. Tệp này chứa thông tin về tất cả các tài nguyên mà Terraform đang quản lý.\nState Backend: Terraform có thể lưu trữ state trên các dịch vụ lưu trữ từ xa như Amazon S3, Google Cloud Storage, Azure Blob Storage, hay Terraform Cloud. Điều này giúp chia sẻ state giữa các thành viên trong nhóm và giữ an toàn cho state.\n2. Cách terraform connect với clouds Terraform gửi request đến public API của clouds. Ở phía clouds sẽ authentication các request này. Terraform sử dụng các provider để đính kèm thông tin trong quá trình authentication. Các provider như là google platform provier, aws provider, azure provider,… Để hỗ trợ quá trình authentication ta sẽ cần services account (IAM) để cung cấp các permission. 3. Terraform Lifecycle Khi làm việc với terraform thì ta cần nắm được 4 lệnh cơ bản này:\nTerraform Init: Dùng để khởi tạo env ở local (initialization workspace). Lệnh này sẽ đọc các scrips mình đã tạo, kiểm tra version và download các API package cần thiết cho quá trình deploy. Chạy terraform init ở lần đầu tiên hoặc khi ta thêm một số provider, các public/private module vào bên trong terraform code của mình. Terraform Plan: So sánh trạng thái của môi trường local và trên cloud (cụ thể là so sánh trong states file). Đưa ra các execution-plan, như là các thay đổi trước hoặc sau khi deploy. Quá trình này chưa deploy bất cứ thứ gì lên clouds nhé. Terraform Apply: Thực hiện deploy, đẩy các thay đổi của source code lên cloud. Tạo ra state files. Terraform Destroy: Nghe tên là hiểu, xóa toàn bộ infrastructure đã deploy trước đó. 4. Các blocks trong terraform 1. Provider Block Provider block được sử dụng để định nghĩa và cấu hình nhà cung cấp dịch vụ mà Terraform sẽ tương tác, như AWS, Azure, Google Cloud,\u0026hellip;\n2. Terraform Block Terraform block được sử dụng để cấu hình các thiết lập toàn cục của Terraform, như phiên bản yêu cầu của Terraform, backend, và các provider mặc định.\n3. Resource Block Resource block được sử dụng để tạo và quản lý tài nguyên trong nhà cung cấp dịch vụ, như instance EC2, bucket S3,\u0026hellip;\n4. Variable Block Variable block được sử dụng để định nghĩa các biến đầu vào, cho phép người dùng tùy chỉnh các giá trị trong cấu hình Terraform.\n5. Module Block Module block được sử dụng để gọi và sử dụng các module Terraform, giúp tái sử dụng cấu hình và tổ chức mã nguồn tốt hơn.\n6. Data Block Data block được sử dụng để truy vấn thông tin về các tài nguyên đã tồn tại hoặc các dịch vụ từ nhà cung cấp dịch vụ, mà không tạo ra hoặc thay đổi bất kỳ tài nguyên nào.\n7. Locals Block Locals block được sử dụng để định nghĩa các biến cục bộ, giúp đơn giản hóa và tái sử dụng các giá trị phức tạp trong cấu hình Terraform.\n8. Output Block Output block được sử dụng để định nghĩa các biến đầu ra (output variables), cung cấp thông tin hữu ích sau khi triển khai hạ tầng. Các đầu ra này có thể bao gồm ID của tài nguyên, địa chỉ IP, v.v.\n9. Backend Block Backend block được sử dụng để định nghĩa và cấu hình backend, nơi lưu trữ trạng thái của Terraform.\nCác block này sẽ được viết trong các tệp terraform có đuôi .tf, dưới đây sẽ là các tệp .tf phổ biến cho việc biểu diễn code terraform trở nên có tổ chức hơn.\n5. Các tệp trong terraform 1. main.tf main.tf là tệp chính trong cấu hình Terraform, chứa định nghĩa các tài nguyên (resources block) và các cấu hình cần thiết để triển khai cơ sở hạ tầng (locals block, terraform block, module block,\u0026hellip;).\n2. variables.tf variables.tf được sử dụng để định nghĩa các biến đầu vào (variables block) mà có thể được tham chiếu trong các tệp cấu hình khác. Điều này giúp tái sử dụng và quản lý cấu hình dễ dàng hơn.\n3. output.tf output.tf được sử dụng để định nghĩa các biến đầu ra (output block), cung cấp thông tin hữu ích sau khi triển khai hạ tầng. Các đầu ra này có thể bao gồm ID của tài nguyên, địa chỉ IP,\u0026hellip;\n4. vars.tfbackend vars.tfbackend thường được sử dụng để cấu hình backend cho Terraform, nơi trạng thái của Terraform sẽ được lưu trữ (như trong S3, Azure Blob Storage, v.v.). Tệp này thường được bao gồm trong lệnh terraform init để thiết lập backend. Và trong workshop này thì mình sẽ cấu hình backend lưu trữ trên S3.\n5. terraform.tfvars terraform.tfvars được sử dụng để cung cấp các giá trị mặc định cho các biến đầu vào đã được định nghĩa trong variables.tf. Tệp này giúp tách biệt cấu hình và giá trị biến, cho phép dễ dàng thay đổi cấu hình mà không cần chỉnh sửa tệp cấu hình chính.\n6. providers.tf providers.tf được sử dụng để định nghĩa các nhà cung cấp dịch vụ (providers block) mà Terraform sẽ tương tác, như AWS, Azure, Google Cloud, v.v. Tệp này cũng có thể chứa cấu hình cho các nhà cung cấp, như vùng (region), thông tin xác thực (credentials), v.v.\nViệc tách biệt các cấu hình này giúp duy trì và quản lý dự án Terraform dễ dàng hơn, đảm bảo cấu hình rõ ràng và có tổ chức.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/","title":"Tạo một project hoàn chỉnh với Terraform và AWS services","tags":[],"description":"","content":"Tổng quan Với Workshop 01 của mình là hướng dẫn bạn phát triển và triển khai tự động một trang web tĩnh trên AWS cloud với các dịch vụ Cloud9, S3, Codepiple, Cloudfront, Route53,\u0026hellip;\nThì với Worksop 02 này chúng ta cùng tìm hiểu về cách làm sao có thể provisioning infracstructure trên aws dưới dạng mã bằng một công cụ mã nguồn mở là Terraform do HashiCorp phát triển, cùng với đó là cách kết hợp các dịch vụ serverless, CI/CD, mornitoring và management của AWS.\nCùng xem diagram dưới đây để hình dung ra bức tranh toàn cảnh của workshop này.\nNội dung 1. Giới thiệu 2. Điều kiện tiên quyết 3. Chuẩn bị repository phía gibhub 4. Terraform và những điều cần biết 5. Cung cấp cơ sở hạ tầng và kiểm tra 6. Dọn dẹp tài nguyên "},{"uri":"https://bibichannel.github.io/workshop-02/vi/2-prerequisites/2.1-createiam/","title":"Tạo User Groups và IAM User","tags":[],"description":"","content":"Trước khi tạo IAM User ta sẽ tạo một User groups cấp policies cần thiết, việc tạo user groups giúp ta dễ dàng kiểm soát tập trung các users, phân loại user theo vai trò trong tổ chức, cũng như việc cấp quyền, thêm bớt các user một cách linh hoạt.\nTiếp theo IAM User gán vào User groups chúng ta vừa tạo là xong. User mới này sẽ kế thừa các quyền từ User groups\nChúng ta sẽ sử dụng user này để thực hiện uỷ quyền cho terraform dưới local của chúng ta, giúp ta có thể sử dụng terraform để test cấu hình trên aws.\nTruy cập vào IAM console:\nChọn User groups. Nhấn vào Create group. Chúng ta sẽ tạo group có tên là DevOpsGroup. Ở phần Attach permissions policies chọn policies AdministratorAccess. Nhấn Create user group. Và dưới đây là kết quả sau khi tạo. Việc chọn policy AdministratorAccess. Vì workshop này mục tiêu không phải là về bảo mật nên để cho nhanh mình sẽ sử dụng policy này. Mình không khuyến khích các bạn sử dụng policy trên vì nó có đặc quyền khá rộng. Hãy tự tạo cho mình policy với các quyền giới hạn cần thiết cho việc bảo mật bạn nhé.\nTiếp theo ta sẽ tiến hành tạo IAM User.\nNhấn chọn User và click vào Create user. Nhập tên user là terraform. Chọn Next. Ở phần Set permissions chọn options Add user to group. Chọn DevOpsGroup ta mới tạo vừa nãy. Chọn Next và chọn Create User. Giao diện sau khi tạo xong user. Tiếp theo ta sẽ tạo Access key cho user để sử dụng user này vơi AWS CLI. Click vào terraform user ta vừa tạo, chọn mục Sercurity Credentials. Cuộn chuột xuống phần Access keys ta nhấn Create access keys. Use case ta chọn Command Line Interface (CLI). Tích I understand the above recommendation and want to proceed to create an access key và chọn Next. Ở phần Set description tag nhập Check the terraform code call aws api Chọn Create access key Chọn Download access key .csv Vậy là bạn đã hoàn thành xong bước tạo User groups và IAM user, hãy đến với bước làm tiếp theo nhé.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/3-setupgithub/3.1-createterraformrepo/","title":"Terraform IaC đến AWS Cloud","tags":[],"description":"","content":"Source code bạn dùng cho phần này sẽ ở đây terraform-aws-continuous-docker-deployment-to-aws-fargate. Bạn có thể fork thẳng từ repo của mình về Với Repository name là tên trùng với tên bạn đặt lúc tạo role cho OIDC bước 2.2\nNhấn Create fork.\nỞ giao diện repository bạn vừa tạo hoặc fork ta truy cập setting.\nChọn Secrets and variables, click vào Actions.\nTa sẽ tiến hành tạo 2 repository secrets mới với nội dung như sau:\nTERRAFORM_BUCKET_NAME là tên của bucket bạn đã tạo ở bước 2.3. CODESTAR_CONNECTION_ARN chứa ARN của connection ta tạo ở bước 2.4. Với 2 variables secrets trên sẽ được sử dụng trong quá trình chạy action khi workflow github được kích hoạt.\nChúng ta cùng tìm hiểu sơ qua các thành phần trong repository này Cây thư mục của repo này như sau:\nỞ đây sẽ có 3 thư mục chính đó là:\nmodules: chứa các module của terraform. .github: chứa workflow file của github, dùng để chạy github action. static: chứa thư mục hình ảnh cho viết Readme.md file. Ngoài các file có đuôi .tf mình sẽ giới thiệu về phần sau, thì ta sẽ quan tâm những file sau:\nterraform-deploy.yml: là một file cấu hình YAML dùng trong pipeline của (CI/CD) để tự động triển khai cơ sở hạ tầng bằng Terraform. Dưới đây sẽ là nội dung của file. name: Deploy Infrastructure on: workflow_dispatch: inputs: actions: description: \u0026#34;Selecting actions for terraform\u0026#34; required: true default: \u0026#34;plan\u0026#34; type: choice options: - plan - apply - destroy environment: description: \u0026#34;Selecting evironments for terraform\u0026#34; required: true default: \u0026#34;staging\u0026#34; type: choice options: - staging - prod env: AWS_REGION : \u0026#34;us-east-1\u0026#34; permissions: id-token: write # This is required for requesting the JWT contents: read # This is required for actions/checkout jobs: build: runs-on: ubuntu-latest name: DEPLOY INFRASTRUCTURE environment: ${{ github.event.inputs.environment }} steps: - name: Check out repository code uses: actions/checkout@v3 - name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v4 with: aws-region: ${{ env.AWS_REGION }} role-to-assume: arn:aws:iam::590183956208:role/github-oidc-role role-session-name: rolesession - name: Get account id run: | ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text) echo \u0026#34;AWS_ACCOUNT_ID=$ACCOUNT_ID\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV - name: Setup Terraform uses: hashicorp/setup-terraform@v3 with: terraform_version: 1.7.3 terraform_wrapper: false - name: Prepare Terraform env: PROJECT_NAME: \u0026#34;workshop-02\u0026#34; STAGE_NAME: ${{ github.event.inputs.environment }} TERRAFORM_BUCKET_NAME: ${{ secrets.TERRAFORM_BUCKET_NAME }} CODESTAR_CONNECTION_ARN: ${{ secrets.CODESTAR_CONNECTION_ARN }} YOUR_GITHUB_REPOSITORY: \u0026#34;GitHubOrg/GitHubRepo\u0026#34; YOUR_GITHUB_BRANCH: \u0026#34;main\u0026#34; run: | chmod +x setup.sh bash setup.sh terraform init -backend-config=./vars.tfbackend - name: Plan Terraform run: | terraform plan if: ${{ github.event.inputs.actions == \u0026#39;plan\u0026#39; }} - name: Aplly Terraform run: | terraform apply -auto-approve if: ${{ github.event.inputs.actions == \u0026#39;apply\u0026#39; }} - name: Destroy Terraform run: | terraform destroy -auto-approve if: ${{ github.event.inputs.actions == \u0026#39;destroy\u0026#39; }} Với workflow_dispatch sẽ cho phép kích hoạt thủ công với các input:\nactions: Lựa chọn hành động Terraform (plan, apply, destroy). environment: Lựa chọn môi trường (staging, prod). Thiết lập quyền cho việc sử dụng OIDC, được sử dụng ở step có tên là Configure AWS Credentials:\nid-token: write là quyền cần thiết để yêu cầu JWT. Với JWT để lấy thông tin xác thực AWS tạm thời. Bạn có thể đọc thêm ở đây: configure-aws-credentials Ở đây ta sẽ chú ý tới step quan trọng có tên là Prepare Terraform, ở step này ta cần phải định nghĩa các biến môi trường cho step, lấy và sử dụng các variables từ secret github.\nNgoài các biến mà bạn đọc tên cũng biết công dụng ở đó thì đây sẽ là 2 biến đại diện cho repository chứ source code cho application của bạn. YOUR_GITHUB_REPOSITORY: \u0026ldquo;GitHubOrg/GitHubRepo\u0026rdquo; YOUR_GITHUB_BRANCH: \u0026ldquo;main\u0026rdquo; Sau đó ta sẽ chạy script setup.sh và khởi tạo Terraform với cấu hình backend. Đoạn này nếu bạn nào chưa biết về terraform sẽ bắt đầu thấy rối rối đúng không. Mình sẽ giải thích rõ ở phần sau nhé. Về file setup.sh. File này sau khi được chạy sẽ tạo ra 2 file là terraform.tfvars và vars.tfbackend. Chứa các biến cho việc setup terraform. Nếu bạn chưa hiểu về nội dung file workflow, về github action và các component trong đó, hãy đọc thêm github action để hiểu rõ hơn nhé.\nVề phần secret variables Ta có flow sau để bạn có thể hiểu hơn\nKhi worklow được trigger, gihub action sẽ thực hiện lấy secret variables và decrypt nó ra để có thể truy cập được value của biến. Vì các biến được mã hoá nên quá trình là bảo mật.\nTiếp theo các biến sẽ được pass như sau:\nTới step Prepare terraform, ở đây chúng ta đã định nghĩa các biến mỗi trường cho step này nó sẽ tạo ra 2 file terraform.tfvars và vars.tfbackend. Đây đều là 2 file chứa các biến cần thiết để setup và truyền biến vào các module terraform, để các module có thể sử dụng. Khi chúng ta đã cung cấp đủ các input variables rồi thì terraform sẽ được chạy và provisioning infrastructure lên AWS Cloud. "},{"uri":"https://bibichannel.github.io/workshop-02/vi/2-prerequisites/","title":"Chuẩn bị","tags":[],"description":"","content":"Để thực hành được bài lab này các bạn cần phải chuẩn bị cho mình những thứ sau đây để code của chúng ta hoạt động trơn tru. Một điều lưu ý nữa là mình sẽ sử dụng region us-east-1 xuyên suốt workshop này.\nNội dung Tạo User Groups và IAM User Tạo connection OIDC Tạo S3 bucket Tạo CodeStar Connection Cài đặt AWS và Terraform tools "},{"uri":"https://bibichannel.github.io/workshop-02/vi/5-provisioningtesting/5.2-githubaction/","title":"Github action","tags":[],"description":"","content":"Với việc provisioning infrastructure trên github action thì dễ hơn, bạn không cần phải chuẩn bị gì cả.\nTruy cập repository terraform bạn đã tạo ở bước 3.1. Chọn Actions, nhấn vào Deploy Infracstructure rồi chọn Run workflow. Chọn các tham số cần thiết cho nhu cầu của bạn và nhấn run workflow. Bạn có thể truy cập để xem chi tiết, ở đây mình chỉ chạy terraform plan.\nChọn apply cho Selecting actions for terraform và chạy lại, check kết quả như ở bước 5.1.\nỞ đây mình để chạy thử công. Nhưng trong thực tế thì sẽ chạy tự động mỗi khi code terraform được sửa và push. Bạn có thể thử thêm điều kiện trigger trong .github/workflows/terraform-deploy.yml file.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/3-setupgithub/3.2-createstreamlitrepo/","title":"Streamlit application","tags":[],"description":"","content":"Source code bạn dùng cho phần này sẽ ở đây streamlit-app. Bạn có thể fork thẳng từ repo của mình về Với Repository name là tên trùng với tên bạn đặt cho biến YOUR_GITHUB_REPOSITORY ở trong file terraform-deploy.yml của repository bạn tạo ở bước 3.1\nNhấn Create fork.\nChúng ta cùng tìm hiểu sơ qua các thành phần trong repository này Cây thư mục của repo này như sau:\nStreamlit là một open-source app framework giúp ta tạo nhanh một website thuần tuý bằng python không cần có kinh nghiệm front-end. Dockerfile là một file để build source code thành image với nội dung như sau: FROM public.ecr.aws/docker/library/python:3.9.19-slim-bullseye WORKDIR /app COPY main.py requirements.txt /app/ RUN pip3 install -r requirements.txt EXPOSE 8501 ENTRYPOINT [\u0026#34;streamlit\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;main.py\u0026#34;, \u0026#34;--server.port=8501\u0026#34;, \u0026#34;--server.address=0.0.0.0\u0026#34;] Ở đây mình sẽ lấy image base được build từ public registry của aws. Nếu sử dụng images từ docker registry có được không? Thì trong quá trình mình làm, mình đã sử dụng images được lấy từ docker regsitry, nhưng mình nhận ngay một lỗi như sau:\n\u0026ldquo;toomanyrequests: You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: https://www.docker.com/increase-rate-limit\u0026rdquo; Vì docker giới hạn việc pull images từ public registry của nó, nó sử dụng địa chỉ IP để xác thực người dùng và giới hạn tốc độ kéo dựa trên địa chỉ IP. Đối với người dùng ẩn danh, giới hạn tốc độ được đặt thành 100 lần pull mỗi 6 giờ cho mỗi địa chỉ IP. Nên ta sẽ sử dụng Amazon ECR public registry để pull image.\nbuildspec.yml là file cho AWS CodeBuild chạy build. Bạn có thể tham khảo thêm các thành phần trong buildspec file tại Build specification reference for CodeBuild. File có nội dung như sau: version: 0.2 phases: pre_build: commands: # Retrieve an authentication token and authenticate your Docker client to your registry - RESULT=$(aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $REPOSITORY_URL) - echo $RESULT build: commands: # Build the Docker image - docker build -t streamlit-app:latest . - SHORT_VERSION=$(echo \u0026#34;$CODEBUILD_RESOLVED_SOURCE_VERSION\u0026#34; | cut -c 1-8) - docker tag streamlit-app:latest $REPOSITORY_URL:$SHORT_VERSION - docker tag streamlit-app:latest $REPOSITORY_URL:latest - echo $SHORT_VERSION - echo $REPOSITORY_URL post_build: commands: # Push docker images to ECR - docker push $REPOSITORY_URL:latest - docker push $REPOSITORY_URL:$SHORT_VERSION - printf \u0026#39;[{\u0026#34;name\u0026#34;:\u0026#34;streamlit-app\u0026#34;,\u0026#34;imageUri\u0026#34;:\u0026#34;%s\u0026#34;}]\u0026#39; $REPOSITORY_URL:$SHORT_VERSION \u0026gt; imagedefinitions.json artifacts: files: imagedefinitions.json Trong quá trình build sẽ có 3 phase: pre_build: thực hiện login vào AWS Elastic Container Registry. build: build image và gắn tags. Mình sẽ gắn 2 tags cho image được build ra. post_build: push image lên AWS ECR và tạo artifact imagedefinitions.json chứa thông tin của container name và uri container, dùng cho việc deploy lên ECS. "},{"uri":"https://bibichannel.github.io/workshop-02/vi/2-prerequisites/2.2-createoidc/","title":"Tạo OIDC","tags":[],"description":"","content":"Trong architecture của chúng ta sử dụng github repository để thực hiện việc provisioning infrastructure lên AWS Cloud services. Để github có quyền có thể làm điều này chúng ta sẽ cần phải có credentials cho github.\nCách đơn giản nhất như sử dụng local là ta sẽ sử dụng access key của user account ta vừa tạo cấp cho github trong quá trình chạy git action. Nhưng điều này ta cần phải tạo secret trong github, đưa credentails user aws của chúng ta cho bên thứ 3 giữ. Trong quá trình đó nếu có các policies quá 90 ngày cần phải reset password cho user thì cũng rất là tốn thời gian đi cập nhật lại secret key trong github.\nBởi vậy ta sẽ sử dụng một phương pháp cấp quyền khác, mới hơn. Nó sẽ giúp ta tạo một temporary credentials mỗi lần chạy git action, điều này giúp bảo mật và dễ dàng quản lí hơn. Đó là tạo một nhà cung cấp danh tính OpenID Connection (OIDC) trong IAM.\nĐể tạo OIDC trong IAM rất đơn giản.\nTrong giao diện IAM, chọn Identity providers. Chọn Add provider. Trong phần Configure provider chọn OpenID Connect. Mục Provider URL ta nhập URL của IdP: https://token.actions.githubusercontent.com. Mục Audience ta nhập sts.amazonaws.com. Rồi chọn Add provider. Đây là thông tin về Identity providers chúng ta vừa mới tạo. Hãy lưu lại Amazon Resource Name (ARN), ta sẽ cần nó cho việc tạo role. Bạn có thể đọc thêm thông tin về: Create an OpenID Connect (OIDC) identity provider in IAM\nSau khi tạo nhà cung cấp danh tính IAM OIDC, bạn phải tạo một IAM role. Role này cho phép IdP của github yêu cầu temporary security credentials để truy cập vào AWS.\nTrong giao diện IAM, ta chọn Roles, rồi chọn Create role. Tại Select trusted entity, ta tích vào Custom trust policy, rồi nội dung dưới đây vào editor. { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Federated\u0026#34;: providerArn }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;token.actions.githubusercontent.com:aud\u0026#34;: \u0026#34;sts.amazonaws.com\u0026#34; }, \u0026#34;StringLike\u0026#34;: { \u0026#34;token.actions.githubusercontent.com:sub\u0026#34;: \u0026#34;repo:GitHubOrg/GitHubRepo:*\u0026#34; } } } ] } Với phần tử Principal, sử dụng Amazon Resource Name (ARN) của OIDC IdP mà ta đã tạo phía trên. Với phần tử Condition, sử dụng điều kiện StringEquals để giới hạn quyền. Với phần tử StringLike sử dụng repo:GitHubOrg/GitHubRepo:* của bạn, ví dụ như mình để sẽ là repo:bibichannel/terraform-project:*. Chú ý repo này sẽ là tên repo mà bạn lưu code terrafrom. Đây sẽ là điều kiện để IAM có thể assume role cho github ở repository bạn muốn, đó là cách tốt nhất để hạn chế các thực thể có thể đảm nhận vai trò được liên kết với IAM IdP. Bạn có thể đọc thêm thông tin về: Configuring a role for GitHub OIDC identity provider.\nPhần Permissions policies ta add permision AdministratorAccess. Vì để cho nhanh mình sẽ sử dụng quyền này, nhưng trong thực tế hãy áp dụng nguyên tắc đặc quyền tối thiểu để tăng tính bảo mật cho account của bạn.\nĐặt tên cho role: github-oidc-role. Rồi chọn Create role. Với IAM Role cta đã tạo sẽ cấp cho repository trên github quyền truy cập vào tài nguyên AWS trong tài khoản của chúng ta. Và mình sẽ sử dụng role này trong quá trình setup github action. Hãy xem bước tiếp theo nhé.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/4-knowledgeterraform/4.2-terraformflow/","title":"Terrafrom flow","tags":[],"description":"","content":"Ở phần trước ta cũng đã tìm hiểu sơ bộ về các thành phần terraform rồi, thì ở phần này mình sẽ nói chi tiết hơn về source code terraform mình đã cung cấp qua workshop này.\nMình tổ chức việc tạo các resources trong terraform theo dạng module để dễ dàng quản lý. Có tất cả là 11 module.\nVPC: chứa các resources cơ bản tạo nên một VPC trong cloud như: subnet, route table, security groups,\u0026hellip;\nALB, Cloudwatch, CodeBuild, Codepipeline, ECR, ECS, Endpoint. EventBridge, S3, SNS: đọc tên thôi thì bạn cũng có thể biết là cung cấp cho services gì rồi đúng không.\nTrong mỗi modlue sẽ có các file main.tf, variables.tf, output.tf và role.tf (chứa resource tạo permision cho services, tuỳ resource có cần hay không). Về công dụng của các file thì mình đã nêu ở phần 4.1.\nVậy làm sao để bạn có thể tìm thấy các resouces cần thiết, các argument và atribute cho block? Bạn hãy tìm nó tại đây: aws provider registry docs. Đây là document mới nhất thời điểm hiện tại mình viết workshop này, trên đây có tất cả thông tin để bạn có thể viết code terraform và tạo các services bạn muốn.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/3-setupgithub/","title":"Chuẩn bị github repository","tags":[],"description":"","content":"Trong workshop này ta sẽ cần 2 github repo:\nRepository đầu tiên mình sẽ lưu terraform code để provisioning tới aws thông qua git action. Điều này sẽ giúp mình có thể downgrade version mỗi khi cấu hình được thay đổi bị lỗi thông qua việc quản lí version trên github. Và nó cũng giúp chúng ta cũng có thể teamwork được với nhau. Repository thứ hai mình sẽ lưu source code của streamlit app, mỗi khi push code lên repo thì nó sẽ được push event thông qua webhook để Codepipeline được trigger, build và deploy lên ECS Fargate. Nội Dung Terraform IaC đến AWS Cloud Streamlit application "},{"uri":"https://bibichannel.github.io/workshop-02/vi/2-prerequisites/2.3-createbucket/","title":"Tạo S3 Bucket","tags":[],"description":"","content":"Chúng ta sẽ tạo 1 bucket dùng để lưu trữ state file cho terraform. Mình sẽ giải thích chi tiết hơn khi chúng ta vào phần 4\nTrong giao diện Create bucket AWS reigon ta chọn S3 bucket tại region mà ta đang làm lab. Hiện tại mình đang làm lab tại N.Virginia (us-east-1) region. Bucket Type trong khuôn khổ bài lab ta chọn General purpose là đủ. Nhập Bucket name, phải nhập tên duy nhất, bạn có thể chọn tùy ý ở đây mình tạo bucket với tên là backend-tf-bibichannel AWS S3 có thể truy cập public và AWS S3 cung cấp cho chúng ta cách access vào bucket và object của nó bằng API REST. Về cơ bản, đường dẫn cần phải tuân thủ DNS và không thể có hai tên miền giống nhau. Vì vậy, bucket names cần phải là duy nhất để truy xuất nhóm và đối tượng bằng điểm cuối REST API.\nỞ dưới ta sẽ giữ nguyên cấu hình mặc định và click Create bucket.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/4-knowledgeterraform/","title":"Kiến thức về Terraform","tags":[],"description":"","content":"Trước khi provisioning IaC lên AWS Cloud, mình sẽ giới thiệu nhanh về Terraform và các thành phần của nó dành cho các bạn chưa biết.\nNội dung Overview Terraform flow "},{"uri":"https://bibichannel.github.io/workshop-02/vi/2-prerequisites/2.4-createcodestar/","title":"Tạo CodeStar Connection","tags":[],"description":"","content":"Lại để ý một chút về artchitect, ta thấy có một repository của github thực hiện push những sự kiện thay đổi qua github để trigger Codepipeline.\nVì vậy ta cũng cần phải có một công cụ để có thể connect Github tới AWS. Và AWS biết điều đó và cung cấp cho chúng ta một công cụ có tên là Codestar Connection.\nTruy cập CodePipeline. Chọn Connections Chọn Create connection Trong phần Select a provider, tích chọn Github. Đặt Connection name là workshop-02. Chọn Connect to GitHub Trong mục GitHub Apps ta click chọn Install a new app Chuyển hướng url xuất hiện trang đăng nhập account github của bạn, hãy đăng nhập và uỷ quyền cho AWS. Sau khi tạo xong, ta sẽ lưu lại ARN của connection của chúng ta, để sử dụng trong quá trình viết code terraform. Khoan đã !!! Bài này sử dụng terraform để provisioning infrastructure trên AWS, vậy tại sao ta không viết code để tạo luôn services này? Lúc đầu mình cũng có suy nghĩ này, nhưng khi ta viết code tạo CodeStar Connection thì khi tạo ra service này sẽ ở trạng thái PENDING, và ta sẽ cần vô tương tác trong AWS Console để nó connect thành công. Điều này sẽ ảnh hưởng tới việc tự động hoá, làm cho quá trình tự động hoá bị gián đoạn. Nên ta sẽ tạo service này trước để quá trình IaC được trơn tru.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/2-prerequisites/2.5-installtools/","title":"Cài đặt tools","tags":[],"description":"","content":"Ở phần này ta sẽ cần cài đặt AWS CLI và Terraform CLI dưới local.\nĐể cài đặt AWS CLI hãy xem link sau: Install to the latest version of the AWS CLI Sau khi bạn đã cài đặt được AWS CLI, ta thực hiện tạo profile để sử dụng. Lúc này ta sẽ sử dụng terraform user ta đã tạo ở bước .\nTruy cập PowerShell gõ câu lệnh sau.\naws configure --profile \u0026lt;profile-name\u0026gt; Profile name tuỳ bạn đặt, với mình sẽ đặt là terraform. Tiến hành nhập các thông tin cần thiết. Để sử dụng profile ta vừa import ta sẽ set biến môi trường cho nó: #### CMD Windows set AWS_PROFILE=profile_name #### Powershell Windows $env:AWS_PROFILE=\u0026#39;profile_name\u0026#39; #### Linux or Mac export AWS_PROFILE=profile_name kiểm tra lại xem profile đã được sử dụng chưa aws sts get-caller-identity kết quả sau khi chạy các câu lệnh trên, mình đã sử dụng được đúng profile mình muốn. Thực hiện cài đặt terraform Thực hiện theo hướng dẫn sau đây để cài đặt terraform trên windows: Install Terraform for Windows Sau khi cài đặt xong hãy check version bạn sử dụng, hiện tại version của mình là v1.7.3. Vì terraform là open-source nên nó được cộng đồng hỗ trợ và cập nhật rất nhanh, nên khi bạn thực hiện workshop này có thể version của mình sẽ bị lỗi thời và một vài tính năng trong code terraform mình cung cấp có thể bị outdate. Nhưng đừng lo, vì document được cập nhật liên tục theo version nên bạn có thể tham khảo và tự sửa đổi cho phù hợp.\n"},{"uri":"https://bibichannel.github.io/workshop-02/vi/5-provisioningtesting/","title":"Provisioning &amp; Testing","tags":[],"description":"","content":"Ở phần này mình sẽ hướng dẫn các bạn chạy code trên Local và trên Git Action.\nNội dung Local Git Action "},{"uri":"https://bibichannel.github.io/workshop-02/vi/6-cleanup/","title":"Dọn dẹp tài nguyên","tags":[],"description":"","content":"Hãy huỷ các tài nguyên lần lượt theo list dưới đây.\nSử dụng lệnh dưới đây nếu bạn sử dụng terraform ở local terraform destroy -auto-approve Chạy workflow với tham số detroy ở Selecting actions for terraform để huỷ infrastucture đã được provisioned. Xoá repository nếu cần thiết. "},{"uri":"https://bibichannel.github.io/workshop-02/vi/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://bibichannel.github.io/workshop-02/vi/tags/","title":"Tags","tags":[],"description":"","content":""}]